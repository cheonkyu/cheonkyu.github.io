# Terraform

## 1. IaC와 테라폼

IaC 도구인 테라폼이 출현한 배경과 사용 목적
IaC(코드형 인프라)는 인프라를 자동화하는 것과 같다.

자동화란 각 ‘프로세스’ 작업을 통합하고 재활용성을 높이는 것이 중요하다.

그러나 때때로 자동화는 무수히 많은 반복과 검증 작업을 필요로 하고, 이전보다 더 많은 시간과 노력을 요구하기도 한다.

IaC는 컴퓨터에서 읽을 수 있는 정의 파일을 사용해 인프라나 서비스를 관리하고 프로비저닝하는 프로세스이다.

코드로 인프라를 관리하는 효과
자유롭게 변경 가능
환경 이해가 쉬움
반복적으로 동일한 상태를 만들 수 있음
인프라가 명확하게 정의되어 별도의 문서로 정리하지 않아도 명세가 남는다.

Terraform은 HashiCorp사의 프로비저닝을 위한 IaC 도구이다.

테라폼은 특정 클라우드나 인프라에 종속적이지 않고, 동일한 워크로드를 설계할 수 있다.

### 테라폼의 3가지 철학

- 워크플로에 집중
- 코드형 인프라 (IaC)
- 실용주의

Terraform 구성 방식 : immutable

인프라스트럭처의 상태를 변경할 때, 기존의 인프라스트럭처를 수정하거나 업데이트하는 것이 아니라 새로운 인프라스트럭처를 생성하여 이전 상태의 인프라스트럭처를 교체하는 방식.

AWS CloudFormation 및 Azure ARM Template도 마찬가지로 immutable이다.

Ansible : mutable

## Chapter 2. 실행 환경 구성

테라폼 로컬 작업 환경 구성
테라폼 설치 : Install Terraform
CLI 구성 파일 : CLI Configuration File (.terraformrc or terraform.rc)

## Chapter 3 - (1) 기본 사용법

테라폼 기본 명령어

terraform init

테라폼 구성 파일이 있는 작업 디렉터리(root module)을 초기화한다.

테라폼 코드에 사용된 구문을 기반으로 필요한 프로바이더 플러그인을 찾고 설치하는 과정이 실행된다.

init 수행 시 프로바이더 종속성을 고정시키는 .terraform.lock.hcl 파일이 생성된다.

작업자가 의도적으로 프로바이더 또는 모듈 버전을 변경하기 위해서는 terraform init -upgrade를 수행해야 한다.

---

terraform validate

원격 작업이나 API 작업은 발생하지 않고, 테라폼 구성 파일의 코드적인 유효성을 확인한다.

문법 종속성, 속성 이름이나 연결된 값의 정확성 확인을 수행한다.

---

terraform plan

인프라의 변경 사항에 관한 실행 계획을 생성한다.

커맨드 결과로 리소스에 정의 가능한 다른 옵션의 내용과 기본값이 자동 입력되어 적용되는 것을 확인할 수 있다. 이를 통해 해당 구성이 특정 리소스에 대해 생성될 때 어떤 값이 기본값으로 설정되는지 확인할 수 있다.

---

terraform apply

계획을 기반으로 작업을 실행한다.
테라폼은 선언적 구성 관리를 제공하는 언어로 멱등성(idempotence)를 갖고, 이후에 추가로 설명될 상태를 관리하기 때문에 동일한 구성에 대해서는 다시 실행하거나 변경하는 작업을 수행하지 않는다.

테라폼은 선언적으로 동작하기 때문에 현재의 코드 상태와 적용할 상태를 비교해 일치시키는 동작을 수행한다.

terraform validate와 terraform plan을 먼저 실행해 변경 사항 적용 전에 검증하고 승인하는 단계를 추가할 수 있으므로 두 동작을 분리해 사용하길 권장.

-replace

프로비저닝이 완료된 이후 실행 계획에 프로비저닝할 대상이 없지만, 사용자가 필요에 의해 특정 리소스를 다시 생성해야하는 경우, -replace 옵션으로 대상 리소스 주소를 지정하면 대상을 삭제 후 생성하는 실행 계획이 발생한다. terraform plan과 terraform apply 모두 적용 가능하고, 여러 번 적용 가능한 옵션.
terraform apply -replace=local_file.abc

---

terraform destroy
테폼 구성에서 관리하는 모든 개쳬를 제거한다. 일부만 제거하기 위해서는 삭제하려는 항목을 코드에서 제거하고 다시 terrafom apply를 실행한다. terraform destroy와 terraform apply -destroy는 동일한 명령이다. terrafrom plan -destroy를 통해 terraform destroy를 위한 실행 계획을 생성할 수 있다.

-auto-approve
terraform apply와 destroy 작업에서 자동 승인 기능을 부여한다.

---

terraform fmt
가독성을 높이기 위해 테라폼 구성 파일을 표준 형식과 표준 스타일로 적용한다.

---

terraform graph
리소스 연관 관계를 확인한다.

1. Graphviz (dot) language support for Visual Studio Code 확장 추가
2. terraform graph 실행 결과 저장
   terraform graph > graph.dot
3. 그래프 시각화
   VS Code에서 우측 상단의 […] 버튼 > Enable preview editor를 통해 시각화할 수 있다.

HashiCorp사에서 IaC와 구성 정보를 명시하기 위해 개발된 오픈소스 도구.

---

테라폼 버전
표기 방식 : semantic versioning ( Major.Minor.Patch )
terraform, module에서 버전 사용 가능.
Major 버전 : 내부 동작의 API가 변경 또는 삭제되거나 하위 호환이 되지 않는 버전
Minor 버전 : 신규 기능이 추가되거나 개선되고 하위 호환이 가능한 버전
Patch 버전 : 버그 및 일부 기능이 개선된 하위 호환이 가능한 버전
required_version : 테라폼 버전을 명시한다. 테라폼 버전에 대한 변경 내역은 다음 링크에서 확인 가능 : Changelog
required_providers : 테라폼 블록에서 각 프로바이더의 이름에 소스 경로와 버전을 명시한다.

1. terraform 블록
   테라폼의 구성을 명시한다. 다른 사람과 함께 작업할 때는 버전을 명시적으로 선언하고 필요한 조건을 입력하여 실행 오류를 최소화할 것을 권장한다.

2. backend 블록
   테라폼 실행 시 저장되는 state(상태 파일)의 저장 위치를 선언한다. 테라폼에서는 하나의 백엔드만 허용한다. 협업을 고려한다면 상태 저장 파일을 공유할 수 있는 외부 백엔드 저장소가 필요하며 이는 동시에 여러 작업자가 접근해 사용할 수 있는 공유 스토리지와 같은 개념을 갖는다. state의 안전한 보관을 고려한다면 고가용성과 백업이 지원되는 저장소를 고려할 수 있다.
   state 잠금 동작
   공유되는 백엔드에 state가 관리되면 테라폼이 실행되는 동안 .terraform.tfstate.lock.info 파일이 생성되어 해당 state를 동시에 사용하지 못하도록 잠금처리를 한다.
   백엔드 설정 변경
   백엔드가 설정되면 Init 명령어를 수행해 state의 위치를 재설정해야 한다. 새로운 백엔드 위치 설정 시, 두가지 옵션이 존재한다.
   이전 구성 유지 (default) : -migrate-state는 terraform.tfstate의 이전 구성에서 최신의 state 스냅샷을 읽고 기록된 정보를 새 구성으로 전환한다.
   새로 초기화 : -reconfiguresms init를 실행하기 전에 terraform.tfstate 파일을 삭제해 테라폼을 처음 사용할 때처럼 이 디렉터리를 초기화하는 동작이다.
3. resource 블록
   선언된 항목을 생성하는 동작을 수행한다.
   resource "<리소스 유형>" "<이름>" {
   <인수> = <값>
   }
   리소스 유형은 프로바이더에 종속성을 갖는다. 특정 프로바이더 유형만 추가해도 terraform init을 수행하면 해당 프로바이더를 설치한다.
   3-1. 종속성
   테라폼의 종속성은 resource, module 선언으로 프로비저닝되는 각 요소의 생성 순서를 구분 짓는다.
   암시적 종속성 : 기본적으로 다른 리소스에서 값을 참조해 불러올 경우 생성 선후 관계에 따라 자동으로 연관 관계가 정의된다.
   명시적 종속석 : depends_on 메타인수를 활용하여 강제로 리소스 간 종속성을 부여한다.
   3-2. 리소스 속성 참조
   리소스 구성에서 참조 가능한 값은 인수와 속성이다. 리소스가 생성될 때, 사용자가 입력한 ‘인수’를 받아 실제 리소스가 생성되면 일부 리소스는 자동으로 기본갑이나 추가되는 ‘속성’이 부여된다.
   Arguments(인수): 리소스 생성 시 사용자가 선언하는 값.
   Attributes(속성): 사용자가 설정하는 것은 불가능하지만 리소스 생성 이후 획득 가능한 리소스 고유 값

```
<리소스 유형>.<이름>.<인수>
<리소스 유형>.<이름>.<속성>
```

3-3. 수명 주기
리소스의 기본 수명주기를 작업자가 의도적으로 변경하는 메타인수. 테라폼의 기본 수명주기는 삭제 후 생성이다.

create_before_destroy
: true로 선언되면 수정된 리소스를 먼저 생성 후 삭제된다. 단, 생성되는 리소스가 기존 리소스로 인해 생성이 실패되거나 삭제 시 함께 삭제될 수 있으니 주의해야 한다.

prevent_destroy
: 작업자가 의도적으로 특정 리소스의 삭제를 방지하고 싶은 경우에 사용한다. 그러나, 테라폼 수명주기(삭제→생성)에 따라 수행되는 리소스에 prevent_destroy가 활성화되어 있으면 해당 리소스 구성 수정 후 terraform apply 시 실패하게 된다.

ignore_changes
: 리소스 요소의 인수를 지정해 수정 계획에 변경 사항이 반영되지 않도록 한다. 모든 변경 사항을 무시하고 싶다면 ignore_changes = all로 설정할 수 있다.

precondition
: 리소스 생성 이전에 입력된 인수 값을 검증하는 데 사용하여 프로비저닝 이전에 미리 약속된 값 이외의 값 또는 필수로 명시해야 하는 인수 값을 검증한다. 프로비저닝해야 하는 클라우드 인프라의 VM을 생성할 때 내부적으로 검증된 이미지의 id를 사용하는지, 스토리지 암호화 설정이 되어있는지 등을 확인하고 사전에 잘못된 프로비저닝을 실행할 수 없도록 구성할 수 있다.

postcondition
: 프로비저닝 변경 이후 결과를 검증함과 동시에 의존성을 갖는 다른 구성의 변경을 막는다. 특히 프로비저닝 이후에 생성되는 속성값이 있으므로 영향을 받는 다른 리소스가 생성되기 전에 예상되지 않은 프로비저닝 작업을 방지할 수 있다.

### (3) 데이터 소스

테라폼으로 정의되지 않은 외부 리소스 또는 저장된 정보를 테라폼 내에서 참조할 때 사용한다.
data "<리소스 유형>" "<이름>" {
<인수> = <값>
}

데이터 소스 참조

```
data.<리소스 유형>.<이름>.<속성>
```

### (4) Input variable

인프라를 구성하는 데 필요한 속성 값을 정의해 코드의 변경 없이 여러 인프라를 생성하는 것이 목적이다. 프로비저닝 실행 시에 원하는 값으로 변수에 정의할 수 있다.

variable "<이름>" {
<이름> = <값>
}
메타인수
default : 변수에 할당되는 기본값 정의
type : 변수에 허용되는 값 유형의 정의
description : 입력 변수의 설명
validation : 변수 선언의 제약조건을 추가해 유효성 검사 규칙을 정의
sensitive : 민감한 변수 값임을 알리고 테라폼의 출력문에서 값 노출을 제한
nullable : 변수에 값이 없어도 됨을 지정
유효성 검사

입력변수 블록 내 valiation 블록을 사용해 사용자 지정 유효성 검사가 가능하다. validation 블록에서 condition에 지정되는 규칙이 true 또는 false를 반환해야 하며, error_message는 condition 값의 결과가 false인 경우 출력되는 메시지를 정의한다. valudation 블록은 중복으로 선언할 수 있다. regrex 함수는 문자열에 정규식을 적용하고 일치하는 문자열을 반환하고, 여기에 can 함수를 함께 사용하면 정규식에 일치하지 않는 경우의 오류를 검출한다.

변수 참조
variable은 코드 내에서 var.<이름>으로 참조된다.

민감한 변수 취급
변수 선언에 sensitive=ture를 추가한다. 추가 시, 테라폼의 계획 출력에서 참조되는 변수 값이 (sensitive)로 감춰지는 것을 확인할 수 있다. 민감한 변수로 지정해도 terraform.tfstate 파일에는 결과물이 평문으로 기록되므로 State 파일의 보안에 유의해야 한다.

변수 우선순위
숫자가 작을수록 우선순위도 낮다.
실행 후 입력 (변수에 값이 선언되지 않아 CLI에서 입력)
variable 블록의 default 값
환경 변수 (TF*VAR*변수이름)
시스템 환경 변수의 접두사에 TF*VAR*가 포함되면 그 뒤의 문자열의 변수 이름으로 인식한다.

```sh
// Unix/Linux/macOS
export TF_VAR_my_var=var1
```

```powershell
// Windows Powershell
$Env:TF*VAR_my_var="var1"
```

terraform.tfvars에 정의된 변수 선언
\*. auto.tfvars에 정의된 변수 선언
\_.auto. tfvars.json에 정의된 변수 선언
CLI 실행 시 -var 인수에 지정 또는 -var-file로 파일 지정
terraform plan -var=my_var=var7

terraform plan -var=my_var=var7 -var=my_var=var8

terraform plan -var=my_var=var7 -var-file=my_var=var9
.tfvars 확장자로 생성된 파일에 변수를 미리 기입하면 실행 시 입력해야 하는 변수 값을 하나의 파일에서 관리할 수 있다. Terraform Cloud에서 변수 정의 시, terraform.tfvars 파일 생성되어 사용자가 의도한 입력변수 값이 덮여 쓰이지 않도록 \*.auto.tfvars 형태의 파일을 지원한다.

### (5) local variable

외부에서 입력되지 않고, 코드 내에서만 가공되어 동작하는 값을 선언한다.

입력 변수와 달리 선언된 모듈 내에서만 접근 가능하고, 변수처럼 실행 시에 입력받을 수 없다.

값이나 표현식을 반복적으로 사용할 수 있으나, 빈번하게 여러 곳에서 사용되는 경우 실제 값에 대한 추적이 어려워져 유지 관리 측면에 부담이 발생할 수 있다.

locals에 선언한 로컬 변수 이름은 전체 루트 모듈 내에 유일해야 한다.

### (6) output variable

루트 모듈에서 사용자가 확인하고자 하는 특정 속성 출력

자식 모듈의 특정 값을 정의하고 루트 모듈에서 결과를 참조

서로 다른 루트 모듈의 결과를 원격으로 읽기 위한 접근 요소 (ex: 자바의 getter)

sensitive의 경우 값이 출력되지 않으므로 디버깅 목적보다는 다른 모듈에서 참조하기 위한 목적에서 활용된다.
